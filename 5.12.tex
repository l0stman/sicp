\documentclass[a4paper,12pt]{article}
\usepackage{listings}
\lstset{language=Lisp}
\newcommand{\subpar}[1]{\medskip \noindent #1.}

\begin{document}

Firstly, we extend the message-passing interface to the machine

\begin{lstlisting}
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '())
        (sorted-instructions '())
        (entry-points-registers '())
        (saved-or-restored-registers '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Multiply defined register: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Unknown register:" name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq) (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register) allocate-register)
              ((eq? message 'get-register) lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              ((eq? message 'install-sorted-instructions)
               (lambda (insts)
                 (set! sorted-instructions insts)))
              ((eq? message 'sorted-instructions)
               sorted-instructions)
              ((eq? message 'add-entry-point-register)
               (lambda (reg)
                 (unless (memq reg entry-points-registers)
                   (set! entry-points-registers
                         (cons reg entry-points-registers)))
                 'done))
              ((eq? message 'entry-points-registers)
               entry-points-registers)
              ((eq? message 'add-saved-or-restored-register)
               (lambda (reg)
                 (unless (memq reg saved-or-restored-registers)
                   (set! saved-or-restored-registers
                         (cons reg saved-or-restored-registers)))
                 'done))
              ((eq? message 'saved-or-restored-registers)
               saved-or-restored-registers)
              (else (error "Unknown request -- MACHINE" message))))
      dispatch)))
\end{lstlisting}

Secondly, we define procedures that sorts a vector and that remove
duplicates in a sorted vector.

\begin{lstlisting}
(define (insert-sort! v cmp)
  (do ((j 1 (+ j 1)))
      ((>= j (vector-length v)) v)
    (let ((key (vector-ref v j)))
      (do ((i (- j 1) (- i 1)))
          ((or (negative? i)
               (cmp (vector-ref v i) key))
           (vector-set! v (+ i 1) key))
        (vector-set! v (+ i 1) (vector-ref v i))))))

(define (remove-duplicates v)
  (define (iter i elt res)
    (cond ((>= i (vector-length v))
           (reverse (cons elt res)))
          ((equal? (vector-ref v i) elt)
           (iter (+ i 1) elt res))
          (else
           (iter (+ i 1)
                 (vector-ref v i)
                 (cons elt res)))))
  (if (zero? (vector-length v))
      '()
      (iter 1 (vector-ref v 0) '())))
\end{lstlisting}

Now we can define a procedure that sorts by instruction type with
duplicates removed.

\begin{lstlisting}
(define (sort-insts insts)
  (define (cmp i1 i2)
    (cond ((null? i1) #t)
          ((null? i2) #f)
          ((equal? (car i1) (car i2))
           (cmp (cdr i1) (cdr i2)))
          ((pair? (car i1))
           (and (pair? (car i2))
                (cmp (car i1) (car i2))))
          ((pair? (car i2)) #t)
          ((number? (car i1))
           (or (symbol? (car i2))
               (< (car i1) (car i2))))
          ((number? (car i2)) #f)
          (else
           (string<? (symbol->string (car i1))
                     (symbol->string (car i2))))))
  (remove-duplicates
   (insert-sort! (list->vector insts) cmp)))

(define (assemble controller-text machine)
  (extract-labels controller-text
                  (lambda (insts labels)
                    (update-insts! insts labels machine)
                    ((machine 'install-sorted-instructions)
                     (sort-insts (map instruction-text insts)))
                    insts)))
\end{lstlisting}

We modify \lstinline!make-goto! to install in the machine the name of
registers used to hold entry points

\begin{lstlisting}
(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let* ((reg-name (register-exp-reg dest))
                  (reg (get-register machine reg-name)))
             ((machine 'add-entry-point-register)
              reg-name)
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction -- ASSEMBLE"
                       inst)))))
\end{lstlisting}

We also modify \lstinline!make-save! and \lstinline!make-restore! to
add to the machine the names of saved or restored registers.

\begin{lstlisting}
(define (make-save inst machine stack pc)
  (let* ((reg-name (stack-inst-reg-name inst))
         (reg (get-register machine reg-name)))
    ((machine 'add-saved-or-restored-register)
     reg-name)
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))

(define (make-restore inst machine stack pc)
  (let* ((reg-name (stack-inst-reg-name inst))
         (reg (get-register machine reg-name)))
    ((machine 'add-saved-or-restored-register)
     reg-name)
    (lambda ()
      (set-contents! reg (pop stack))
      (advance-pc pc))))
\end{lstlisting}

Finally, we modify \lstinline!make-register! and
\lstinline!make-assign! so that each register stores the sources from
which it's assigned.

\begin{lstlisting}
(define (make-register name)
  (let ((contents '*unassigned*)
        (assign-sources '()))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value) (set! contents value)))
            ((eq? message 'add-assign-source)
             (lambda (src)
               (unless (member src assign-sources)
                 (set! assign-sources
                       (cons src assign-sources)))
               'done))
            ((eq? message 'assign-sources)
             assign-sources)
            (else
             (error "Unknown request -- REGISTER" message))))
    dispatch))

(define (make-assign inst machine labels operations pc)
  (let ((target (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      ((target 'add-assign-source) value-exp)
      (lambda ()                        ; execution procedure for assign
        (set-contents! target (value-proc))
        (advance-pc pc)))))
\end{lstlisting}

Here're what we obtain with the Fibonacci machine.
\begin{lstlisting}
> (define fib-machine
    (make-machine
     '(val n continue)
     `((+ ,+) (- ,-) (< ,<))
     '(  (assign continue (label fib-done))
       fib-loop
         (test (op <) (reg n) (const 2))
         (branch (label immediate-answer))
         (save continue)
         (assign continue (label afterfib-n-1))
         (save n)
         (assign n (op -) (reg n) (const 1))
         (goto (label fib-loop))
       afterfib-n-1
         (restore n)
         (restore continue)
         (assign n (op -) (reg n) (const 2))
         (save continue)
         (assign continue (label afterfib-n-2))
         (save val)
         (goto (label fib-loop))
       afterfib-n-2
         (assign n (reg val))
         (restore val)
         (restore continue)
         (assign val
                 (op +) (reg val) (reg n))
         (goto (reg continue))
       immediate-answer
         (assign val (reg n))
         (goto (reg continue))
       fib-done)))
> (fib-machine 'sorted-instructions)
((assign continue (label afterfib-n-1))
 (assign continue (label afterfib-n-2))
 (assign continue (label fib-done))
 (assign n (op -) (reg n) (const 1))
 (assign n (op -) (reg n) (const 2))
 (assign n (reg val))
 (assign val (op +) (reg val) (reg n))
 (assign val (reg n))
 (branch (label immediate-answer))
 (goto (label fib-loop))
 (goto (reg continue))
 (restore continue)
 (restore n)
 (restore val)
 (save continue)
 (save n)
 (save val)
 (test (op <) (reg n) (const 2)))
> (fib-machine 'entry-points-registers)
(continue)
> (fib-machine 'saved-or-restored-registers)
(val n continue)
> ((get-register fib-machine 'val) 'assign-sources)
(((reg n)) ((op +) (reg val) (reg n)))
> ((get-register fib-machine 'n) 'assign-sources)
(((reg val)) ((op -) (reg n) (const 2)) ((op -) (reg n) (const 1)))
> ((get-register fib-machine 'continue) 'assign-sources)
(((label afterfib-n-2)) ((label afterfib-n-1)) ((label fib-done)))
\end{lstlisting}

\end{document}
