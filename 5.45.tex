\documentclass[a4paper,12pt]{article}
\usepackage{listings}
\lstset{language=Lisp}
\newcommand{\subpar}[1]{\medskip \noindent #1.}

\begin{document}

\subpar{a} Since we have modified the explicit-control evaluator
compared to the one used in \textbf{exercise 5.27} to optimize
variable lookup of an operator in an application expression, here are
the new numbers for $n > 1$

\begin{quote}
  \begin{tabular}{|c|c|c|}
    \hline &Maximum depth& Number of pushes \\
    \hline Interpreted factorial & $5 n + 3$ & $24 n - 12$ \\
    \hline Factorial machine & $2(n-1)$ & $2(n-1)$ \\
    \hline Compiled factorial & $2n$ & $4n+1$ \\
    \hline
  \end{tabular}
\end{quote}

We then deduce that the ratio of the number of pushes in the compiled
version to the number of pushes for the interpreted version tends to
$1/6$, and the ratio of the maximum depth tends to $2/5$.  Doing the
same comparisons between the special-purpose factorial machine and the
interpreted version, we obtain respectively $1/12$ and $2/5$.

\subpar{b} The code generated by the compiler for the recursive
factorial is:

\begin{lstlisting}
(assign val
        (op make-compiled-procedure)
        (label entry25)
        (reg env))
(goto (label after-lambda26))
entry25
(assign env (op compiled-procedure-env) (reg proc))
(assign env
        (op extend-environment)
        (const (n))
        (reg argl)
        (reg env))
(save continue)
(save env)
(assign proc (op lookup-in-globenv) (const =))
(assign val (const 1))
(assign argl (op list) (reg val))
(assign val
        (op lexical-address-lookup)
        (const (0 0))
        (reg env))
(assign argl (op cons) (reg val) (reg argl))
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch30))
compiled-branch31
(assign continue (label after-call32))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch30
(assign val
        (op apply-primitive-procedure)
        (reg proc)
        (reg argl))
after-call32
(restore env)
(restore continue)
(test (op false?) (reg val))
(branch (label false-branch28))
true-branch27
(assign val (const 1))
(goto (reg continue))
false-branch28
(save env)
(save continue)
(assign proc (op lookup-in-globenv) (const factorial))
(assign arg1
        (op lexical-address-lookup)
        (const (0 0))
        (reg env))
(assign arg2 (const 1))
(assign val (op -) (reg arg1) (reg arg2))
(assign argl (op list) (reg val))
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch33))
compiled-branch34
(assign continue (label proc-return36))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
proc-return36
(assign arg1 (reg val))
(goto (label after-call35))
primitive-branch33
(assign arg1
        (op apply-primitive-procedure)
        (reg proc)
        (reg argl))
after-call35
(restore continue)
(restore env)
(assign arg2
        (op lexical-address-lookup)
        (const (0 0))
        (reg env))
(assign val (op *) (reg arg1) (reg arg2))
(goto (reg continue))
after-if29
after-lambda26
(perform (op define-variable!)
         (const factorial)
         (reg val)
         (reg env))
(assign val (const ok))
\end{lstlisting}

The factor of $1/2$ as the ratio of the number of pushes of the
special-purpose machine and the compiled code comes from the
unnecessary preserving of the registers \textbf{continue} and
\textbf{env} when evaluating \lstinline!(= n 1)!.

This is done since the compiler doesn't know that \lstinline!=!
modify none of these registers.  By open-coding this primitive, we get
rid of these unnecessary preserving as well as the dispatch to a
compiled branch or a primitive one.  The generated code would be then
as efficient as the special-purpose machine.

\end{document}
